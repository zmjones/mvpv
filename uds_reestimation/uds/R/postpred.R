gamma.range <- function (K.j, j) {
  start <- 1
  end <- K.j[1]
  if (j == 1)
    return (c(start, end))

  for (i in 2:j) {
    start <- start + K.j[i - 1]
    end <- end + K.j[i]
  }

  return (c(start, end))
}

# Posterior predictive dist y.star for the uds.  y.star will be a
# 3-dim array.  Think of this as a series of matrices where each
# matrix is a single draw from the posterior predictive distribution,
# rows within each matrix are cases, and columns within each matrix
# are raters.  So, the dim is nXJxS.  If a given rater didn't rate a
# particular case, we put an NA in the slot.  Works with a posterior
# generated by mroprobit, multi-chain or single (or a single chain
# picked from a multi).
pred.y <- function (post, chain=NULL, thin=1) {

  if (!is.null(chain) & is.mcmc.list(post$sigmasq)) {
    sigma <- post$sigmasq[[chain]]
    gamma <- post$gamma[[chain]]
    z <- post$z[[chain]]
  } else if (is.mcmc.list(post$sigmasq)) {
    sigma <- mcmc(concat.mcmc.list(post$sigmasq))
    gamma <- mcmc(concat.mcmc.list(post$gamma))
    z <- mcmc(concat.mcmc.list(post$z))
  } else {
    sigma <- post$sigmasq
    gamma <- post$gamma
    z <- post$z
  }
  sigma <- sqrt(sigma)

  n <- nrow(post$data) # number of cases
  J <- ncol(post$data) # number of raters
  S <- nrow(z) # the number of simulations

  K.j <- unlist(apply(post$data, 2, max, na.rm=t))-1
  gamma.index <- sapply(1:J, function (j) gamma.range(K.j, j))
  y.star <- array(NA, c(n, J, S/thin))

  cnt <- 1
  for (s in seq(1, S, thin)) { # simulation draws
    print(s)
    z.s <- t(z[s, ])
    sigma.s <- t(sigma[s,])
    gamma.s <- t(gamma[s,])

    for (j in 1:J) { # raters
      gamma.s.j <- gamma.s[gamma.index[1,j]:gamma.index[2,j]]

      # Generate the base theta matrix (this is i X (K_j - 1))
      theta.s.j <- sapply(gamma.s.j,
        function (x) pnorm((x - z.s) / sigma.s[j]))
      # tack on first and last cols
      theta.s.j <- cbind(0, theta.s.j)
      theta.s.j <- cbind(theta.s.j, 1)
      # Make p matrix (this is i X K_j)
      p.s.j <- sapply(2:ncol(theta.s.j),
        function (col) theta.s.j[,col] - theta.s.j[,col-1])
      #print(dim(p.s.j))
      #return(p.s.j)


      y.star[,j,cnt] <- apply(t(apply(p.s.j, 1,
                                    function(p) rmultinom(1,1,p))),
                              1, which.max)
    }
    cnt <- cnt + 1
  }

  return(y.star)
}
